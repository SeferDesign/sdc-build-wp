import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import project from '../lib/project.js';
import log from './logging.js';
import * as sass from 'sass';
import postcss from 'postcss';
import autoprefixer from 'autoprefixer';
import sortMQ from 'postcss-sort-media-queries';
import stylelint from 'stylelint';
import { promises } from 'fs';

function camelToDash(camel) {
	return camel.replace(/[A-Z]/g, m => '-' + m.toLowerCase());
}

export const buildSassTheme = async () => {
	try {
		let theme = JSON.parse(await promises.readFile(project.path + '/theme.json'));
		let themeFileData = `// This file is automatically generated from theme.json. Do not edit.\n`;
		if (theme.settings?.custom) {
			for (var customAttribute in theme.settings.custom) {
				if (customAttribute == 'dirDist') {
					themeFileData += `$themeDirDist: "${theme.settings.custom[customAttribute]}"; // --wp--custom--${camelToDash(customAttribute)}\n`;
				} else if (['breakpoints-rem', 'breakpoint-mobile'].includes(customAttribute)) {
					// handled later in file - see 'fontSizeBase'
				} else {
					themeFileData += `$${customAttribute}: "${theme.settings.custom[customAttribute]}"; // --wp--custom--${camelToDash(customAttribute)}\n`;
					//
				}
			}
		}
		if (theme.styles?.typography) {
			if (theme.styles.typography.fontSize) {
				let fontSizeBase = theme.styles.typography.fontSize;
				themeFileData += `$font-size-base: ${theme.styles.typography.fontSize}; // --wp--preset--font-size\n`;
				if (theme.settings.custom && theme.settings.custom['breakpoints-rem']) {
					for (var breakpoint in theme.settings.custom['breakpoints-rem']) {
						if (theme.settings.custom['breakpoints-rem'][breakpoint].toString().includes('rem')) {
							themeFileData += `$screen-${breakpoint}: ${theme.settings.custom['breakpoints-rem'][breakpoint]}; // --wp--custom--breakpoints-rem--${breakpoint}\n`;
						} else {
							themeFileData += `$screen-${breakpoint}: ${theme.settings.custom['breakpoints-rem'][breakpoint]}rem; // --wp--custom--breakpoints-rem--${breakpoint} (without 'rem')\n`;
						}
						themeFileData += `$screen-${breakpoint}-px: ${theme.settings.custom['breakpoints-rem'][breakpoint].toString().replace('rem', '') * fontSizeBase.replace('px', '')}px;\n`;
					}
					if (theme.settings.custom['breakpoint-mobile']) {
						themeFileData += `$mobile-breakpoint: $screen-${theme.settings.custom['breakpoint-mobile']}; // --wp--custom--breakpoint-mobile \n`;
						themeFileData += `$mobile-breakpoint-px: $screen-${theme.settings.custom['breakpoint-mobile']}-px;\n`;
					}
				}
			}
		}
		if (theme.settings?.typography?.fontFamilies) {
			for (var fontFamily of theme.settings.typography.fontFamilies) {
				themeFileData += `$${fontFamily['slug']}: ${fontFamily['fontFamily']}; // --wp--preset--font-family--${fontFamily['slug']}\n`;
			}
		}
		if (theme.settings?.color?.palette) {
			for (var color of theme.settings.color.palette) {
				themeFileData += `$${color['slug']}: ${color['color']}; // --wp--preset--color--${color['slug']}\n`;
			}
		}
		if (theme.settings?.color?.gradients) {
			for (var color of theme.settings.color.gradients) {
				themeFileData += `$gradient-${color['slug']}: ${color['gradient']};\ // --wp--preset--gradient--${color['slug']}\n`;
			}
		}
		try {
			await promises.writeFile(project.path + '/_src/style/partials/_theme.scss', themeFileData);
		} catch(error) {
			console.error(error);
			log('error', `Failed to write auto-generated _theme.scss - See above error.`);
		}
	} catch(error) {
		console.error(error);
		log('error', `Failed to read theme.json - See above error.`);
	}
};

export const buildSass = async (entry, name, entriesToLint) => {
	let timerStart = Date.now();
	let destinationLayers = name.split('/');
	let destinationPrefix = project.path + '/dist/';
	for (var i = 0; i < destinationLayers.length - 1; i++) {
		destinationPrefix += destinationLayers[i] + '/';
		if (!fs.existsSync(destinationPrefix)) {
			fs.mkdirSync(destinationPrefix);
		}
	}
	let outFile = project.path + '/dist/' + name + '.min.css';
	if (name.startsWith('blocks/')) {
		outFile = project.path + '/' + name + '.min.css';
	}
	let entryLabel = outFile.replace(project.path, '');
	stylelint.lint({
		configFile: path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../.stylelintrc.json'),
		formatter: 'string',
		files: entriesToLint || [entry],
		customSyntax: 'postcss-scss',
		fix: true
	}).then((data) => {
		if (data.errored) {
			console.error(data.output);
			log('error', `Failed linting ${entry.replace(project.path + '/_src/style/', '')} - See above error.`);
			return false;
		}
		try {
			const result = sass.compile(entry, {
				style: 'compressed'
			});
			fs.writeFile(outFile, result.css, function(err) {
				if (err) {
					// console.error(err);
					// log('error', `Failed compiling ${entryLabel} - See above error.`);
					// return false;
				} else {
					if (!fs.existsSync(project.path + '/dist')) {
						fs.mkdirSync(project.path + '/dist');
					}
					if (!fs.existsSync(project.path + '/dist/style')) {
						fs.mkdirSync(project.path + '/dist/style');
					}
					postcss([
						autoprefixer(),
						sortMQ()
					]).process(result.css, { from: undefined }).then(resultPost => {
						fs.writeFile(outFile, resultPost.css, function(err) {
							if (err) {
								console.log(err);
								log('error', `Failed saving ${entryLabel} - See above error.`);
								return false;
							} else {
								log('success', `Built ${entryLabel} in ${Date.now() - timerStart}ms`);
							}
						});
					});
				}
			});
		} catch(error) {
			console.error(error);
			log('error', `Failed building ${entryLabel} - See above error.`);
			return false;
		}
	});
};
