import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import project from '../lib/project.js';
import log from './logging.js';
import * as sass from 'sass';
import postcss from 'postcss';
import autoprefixer from 'autoprefixer';
import sortMQ from 'postcss-sort-media-queries';
import stylelint from 'stylelint';
import { promises } from 'fs';

const buildColors = async () => {
	try {
		let theme = JSON.parse(await promises.readFile(project.path + '/theme.json'));
		let themeFileData = `// This file is automatically generated. Do not edit.\n`;
		if (theme.settings?.typography?.fontFamilies) {
			for (var fontFamily of theme.settings.typography.fontFamilies) {
				themeFileData += `$${fontFamily['slug']}: ${fontFamily['fontFamily']}; // --wp--preset--font-family--${fontFamily['slug']}\n`;
			}
		}
		if (theme.settings?.color?.palette) {
			for (var color of theme.settings.color.palette) {
				themeFileData += `$${color['slug']}: ${color['color']}; // --wp--preset--color--${color['slug']}\n`;
			}
		}
		if (theme.settings?.color?.gradients) {
			for (var color of theme.settings.color.gradients) {
				themeFileData += `$gradient-${color['slug']}: ${color['gradient']};\ // --wp--preset--gradient--${color['slug']}\n`;
			}
		}
		try {
			await promises.writeFile(project.path + '/_src/style/partials/_theme.scss', themeFileData);
		} catch {
			log('error', `Failed to write auto-generated _theme.scss - See above error.`);
		}
	} catch {
		log('error', `Failed to read theme.json - See above error.`);
	}
};

const buildSass = async (entry, name, entriesToLint) => {
	await buildColors();
	let timerStart = Date.now();
	let outFile = project.path + '/dist/' + name + '.min.css';
	if (name.startsWith('blocks/')) {
		outFile = project.path + '/' + name + '.min.css';
	}
	let entryLabel = outFile.replace(project.path, '');
	stylelint.lint({
		configFile: path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../.stylelintrc'),
		formatter: 'string',
		files: entriesToLint || [entry],
		customSyntax: 'postcss-scss',
		fix: true
	}).then((data) => {
		if (data.errored) {
			console.error(data.output);
			log('error', `Failed linting ${entry.replace(project.path + '/_src/style/', '')} - See above error.`);
			return false;
		}
		try {
			const result = sass.compile(entry, {
				style: 'compressed'
			});
			fs.writeFile(outFile, result.css, function(err) {
				if (err) {
					// console.error(err);
					// log('error', `Failed compiling ${entryLabel} - See above error.`);
					// return false;
				} else {
					if (!fs.existsSync(project.path + '/dist')) {
						fs.mkdirSync(project.path + '/dist');
					}
					if (!fs.existsSync(project.path + '/dist/style')) {
						fs.mkdirSync(project.path + '/dist/style');
					}
					postcss([
						autoprefixer(),
						sortMQ()
					]).process(result.css, { from: undefined }).then(resultPost => {
						fs.writeFile(outFile, resultPost.css, function(err) {
							if (err) {
								console.log(err);
								log('error', `Failed saving ${entryLabel} - See above error.`);
								return false;
							} else {
								log('success', `Built ${entryLabel} in ${Date.now() - timerStart}ms`);
							}
						});
					});
				}
			});
		} catch(error) {
			console.error(error);
			log('error', `Failed building ${entryLabel} - See above error.`);
			return false;
		}
	});
};

export default buildSass;
